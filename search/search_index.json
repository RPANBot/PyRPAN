{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About PyRPAN is an async API wrapper made in Python for the Reddit Public Access Network (RPAN), which is Reddit's streaming service. Example import asyncio from pyrpan import PyRPAN rpan = PyRPAN(client_id='client id here', client_secret='client secret here') async def main(): broadcasts = await rpan.get_broadcast(id='stream id here') print(broadcast.url) await rpan.close() asyncio.run(main()) Links Source Code : github.com/b1uejay27/PyRPAN PyPi : pypi.org/project/PyRPAN Discord Server : discord.gg/DfBp4x4","title":"Home"},{"location":"#about","text":"PyRPAN is an async API wrapper made in Python for the Reddit Public Access Network (RPAN), which is Reddit's streaming service.","title":"About"},{"location":"#example","text":"import asyncio from pyrpan import PyRPAN rpan = PyRPAN(client_id='client id here', client_secret='client secret here') async def main(): broadcasts = await rpan.get_broadcast(id='stream id here') print(broadcast.url) await rpan.close() asyncio.run(main())","title":"Example"},{"location":"#links","text":"Source Code : github.com/b1uejay27/PyRPAN PyPi : pypi.org/project/PyRPAN Discord Server : discord.gg/DfBp4x4","title":"Links"},{"location":"code-reference/","text":"Code Reference client PyRPAN Client class for the PyRPAN API Wrapper. Attributes: Name Type Description reddit str The Reddit instance to use to access the Reddit API. top_broadcasts_cache ExpiringDict A cache of the top broadcasts. api_url str URL to access the RPAN API. session aiohttp.ClientSession For creating client session and to make requests. Source code in pyrpan\\client.py class PyRPAN : \"\"\" Client class for the PyRPAN API Wrapper. Attributes ---------- reddit : str The Reddit instance to use to access the Reddit API. top_broadcasts_cache : ExpiringDict A cache of the top broadcasts. api_url : str URL to access the RPAN API. session : aiohttp.ClientSession For creating client session and to make requests. \"\"\" def __init__ ( self , client_id : str , client_secret : str ) -> None : \"\"\" Construct the PyRPAN wrapper. Parameters ---------- client_id : str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. client_secret : str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. \"\"\" self . api_url = \"https://strapi.reddit.com\" self . top_broadcasts_cache = ExpiringDict ( max_len = 3 , max_age_seconds = 300 ) self . reddit = Reddit ( client_id = client_id , client_secret = client_secret , user_agent = \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , ) self . _session = None self . _lock = asyncio . Lock () async def close ( self ) -> None : \"\"\"Close the client session.\"\"\" if self . _session is not None : await self . _session . close () async def fetch ( self , method : str , route : str , * , headers : Optional [ dict ] = None , data : Optional [ dict ] = None ) -> Optional [ dict ]: \"\"\" Fetching a response from the API Parameters ---------- route : str The API route you want to make a call to headers : dict Headers for the API call, Defaults to None data : dict Data for the API call, Defaults to None Returns ------- Optional[dict] The response from the API. \"\"\" if headers is None : headers = {} headers = { \"User-Agent\" : \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , \"Cache-Control\" : \"no-cache\" , ** headers , } if not self . _session : self . _session = aiohttp . ClientSession () async with self . _lock : async with self . _session . request ( method = method , url = self . api_url + route , headers = headers , data = data ) as res : # Handle status codes if res . status in [ 200 , 201 , 204 ]: data = await res . json () if res . status == 400 : raise InvalidRequest ( \"Bad request - Request performed was invalid.\" ) if res . status == 429 : raise InvalidRequest ( \"Too many requests - Slow down your requests.\" ) if res . status == 500 : raise InvalidRequest ( \"Internal Server Error - Something went wrong.\" ) return data async def get_viewer_subreddits ( self ) -> list : \"\"\" Gets a list of the recommended viewer RPAN subreddits. Returns ------- list The list of viewer subreddits. \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/recommended_viewer_subreddits\" ) return data [ \"data\" ] async def get_broadcast ( self , id : str ) -> Optional [ Broadcast ]: \"\"\" Gets a broadcast by ID. Parameters ---------- id : str ID of the broadcast you want to fetch. Returns ------- Broadcast The retrived broadcast or None. \"\"\" data = await self . fetch ( method = \"GET\" , route = f \"/broadcasts/ { id } \" ) if data [ \"status\" ] == \"success\" : payload = data [ \"data\" ] return Broadcast ( payload = payload ) else : return None async def get_broadcasts ( self ) -> Optional [ Broadcasts ]: \"\"\" Fetches all the currently active broadcasts. Returns ------- Broadcasts The retrived broadcasts or None. \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/broadcasts\" ) if data [ \"status\" ] == \"success\" : broadcasts = [] if len ( data [ \"data\" ]): for broadcast in data [ \"data\" ]: payload = broadcast broadcasts . append ( Broadcast ( payload = payload )) return Broadcasts ( contents = broadcasts ) else : return None async def get_last_broadcast ( self , username : str ) -> Optional [ Broadcast ]: \"\"\" Gets the last broadcast of a user. Parameters ---------- username : str The username of the user you want to get the last broadcast for. Returns ------- Broadcast The found last broadcast or None. \"\"\" user = await self . reddit . redditor ( username ) async for submission in user . submissions . new ( limit = 25 ): if self . is_rpan_broadcast ( submission . url ): return await self . submission_to_broadcast ( submission ) return None async def get_top_broadcasts ( self , time_period : str = None ) -> tuple : \"\"\" Gets the top broadcast on each subreddit (from within a specific time period). Parameters ---------- time_period : str The time period from which you would like to get the top broadcasts for. Returns ------- tuple A tuple of the top broadcasts in each subreddit and the time period used. \"\"\" allowed_time_periods = [ \"hour\" , \"day\" , \"week\" , \"month\" , \"year\" , \"all\" , ] if time_period : time_period = time_period . lower () if time_period not in allowed_time_periods : time_period = \"week\" if time_period in self . top_broadcasts_cache : return self . top_broadcasts_cache [ time_period ], time_period else : top_broadcasts = {} for subreddit in constants . RPAN_SUBREDDITS : subreddit = await self . reddit . subreddit ( subreddit ) async for submission in subreddit . search ( 'flair_name:\"Broadcast\"' , sort = \"top\" , time_filter = time_period , limit = 1 , ): top_broadcasts [ subreddit ] = submission self . top_broadcasts_cache [ time_period ] = top_broadcasts return top_broadcasts , time_period async def submission_to_broadcast ( self , submission : Submission ) -> Optional [ Broadcast ]: \"\"\" Turns a PRAW submission into a broadcast class. Parameters ---------- submission : str The submission to turn into a broadcast class. Returns ------- Broadcast The broadcast class. \"\"\" return Broadcast ( payload = { \"post\" : { \"id\" : submission . fullname , \"title\" : submission . title , \"url\" : submission . url , \"authorInfo\" : { \"name\" : submission . author . name }, \"subreddit\" : { \"name\" : submission . subreddit . display_name }, }, \"stream\" : { \"state\" : \"IS_LIVE\" , # TODO: Switch stream state \"publish_at\" : submission . created_utc , }, } ) def format_broadcast_timestamp ( self , timestamp : int ) -> str : \"\"\" Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters ---------- timestamp : int The timestamp to format. Returns ------- str The timestamp in a set format. \"\"\" return datetime . fromtimestamp ( int ( timestamp ), tz = timezone . utc ) def is_rpan_broadcast ( self , link : str ) -> bool : \"\"\" Checks if a link is a valid RPAN broadcast. Parameters ---------- link : str The link to check. Returns ------- bool If the link is a valid RPAN broadcast. \"\"\" if \"reddit.com/rpan/\" in link : return True else : return False __init__ ( self , client_id , client_secret ) special Construct the PyRPAN wrapper. Parameters: Name Type Description Default client_id str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. required client_secret str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. required Source code in pyrpan\\client.py def __init__ ( self , client_id : str , client_secret : str ) -> None : \"\"\" Construct the PyRPAN wrapper. Parameters ---------- client_id : str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. client_secret : str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. \"\"\" self . api_url = \"https://strapi.reddit.com\" self . top_broadcasts_cache = ExpiringDict ( max_len = 3 , max_age_seconds = 300 ) self . reddit = Reddit ( client_id = client_id , client_secret = client_secret , user_agent = \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , ) self . _session = None self . _lock = asyncio . Lock () close ( self ) async Close the client session. Source code in pyrpan\\client.py async def close ( self ) -> None : \"\"\"Close the client session.\"\"\" if self . _session is not None : await self . _session . close () fetch ( self , method , route , * , headers = None , data = None ) async Fetching a response from the API Parameters: Name Type Description Default route str The API route you want to make a call to required headers Optional[dict] Headers for the API call, Defaults to None None data Optional[dict] Data for the API call, Defaults to None None Returns: Type Description Optional[dict] The response from the API. Source code in pyrpan\\client.py async def fetch ( self , method : str , route : str , * , headers : Optional [ dict ] = None , data : Optional [ dict ] = None ) -> Optional [ dict ]: \"\"\" Fetching a response from the API Parameters ---------- route : str The API route you want to make a call to headers : dict Headers for the API call, Defaults to None data : dict Data for the API call, Defaults to None Returns ------- Optional[dict] The response from the API. \"\"\" if headers is None : headers = {} headers = { \"User-Agent\" : \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , \"Cache-Control\" : \"no-cache\" , ** headers , } if not self . _session : self . _session = aiohttp . ClientSession () async with self . _lock : async with self . _session . request ( method = method , url = self . api_url + route , headers = headers , data = data ) as res : # Handle status codes if res . status in [ 200 , 201 , 204 ]: data = await res . json () if res . status == 400 : raise InvalidRequest ( \"Bad request - Request performed was invalid.\" ) if res . status == 429 : raise InvalidRequest ( \"Too many requests - Slow down your requests.\" ) if res . status == 500 : raise InvalidRequest ( \"Internal Server Error - Something went wrong.\" ) return data format_broadcast_timestamp ( self , timestamp ) Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters: Name Type Description Default timestamp int The timestamp to format. required Returns: Type Description str The timestamp in a set format. Source code in pyrpan\\client.py def format_broadcast_timestamp ( self , timestamp : int ) -> str : \"\"\" Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters ---------- timestamp : int The timestamp to format. Returns ------- str The timestamp in a set format. \"\"\" return datetime . fromtimestamp ( int ( timestamp ), tz = timezone . utc ) get_broadcast ( self , id ) async Gets a broadcast by ID. Parameters: Name Type Description Default id str ID of the broadcast you want to fetch. required Returns: Type Description Optional[pyrpan.models.Broadcast] The retrived broadcast or None. Source code in pyrpan\\client.py async def get_broadcast ( self , id : str ) -> Optional [ Broadcast ]: \"\"\" Gets a broadcast by ID. Parameters ---------- id : str ID of the broadcast you want to fetch. Returns ------- Broadcast The retrived broadcast or None. \"\"\" data = await self . fetch ( method = \"GET\" , route = f \"/broadcasts/ { id } \" ) if data [ \"status\" ] == \"success\" : payload = data [ \"data\" ] return Broadcast ( payload = payload ) else : return None get_broadcasts ( self ) async Fetches all the currently active broadcasts. Returns: Type Description Optional[pyrpan.models.Broadcasts] The retrived broadcasts or None. Source code in pyrpan\\client.py async def get_broadcasts ( self ) -> Optional [ Broadcasts ]: \"\"\" Fetches all the currently active broadcasts. Returns ------- Broadcasts The retrived broadcasts or None. \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/broadcasts\" ) if data [ \"status\" ] == \"success\" : broadcasts = [] if len ( data [ \"data\" ]): for broadcast in data [ \"data\" ]: payload = broadcast broadcasts . append ( Broadcast ( payload = payload )) return Broadcasts ( contents = broadcasts ) else : return None get_last_broadcast ( self , username ) async Gets the last broadcast of a user. Parameters: Name Type Description Default username str The username of the user you want to get the last broadcast for. required Returns: Type Description Optional[pyrpan.models.Broadcast] The found last broadcast or None. Source code in pyrpan\\client.py async def get_last_broadcast ( self , username : str ) -> Optional [ Broadcast ]: \"\"\" Gets the last broadcast of a user. Parameters ---------- username : str The username of the user you want to get the last broadcast for. Returns ------- Broadcast The found last broadcast or None. \"\"\" user = await self . reddit . redditor ( username ) async for submission in user . submissions . new ( limit = 25 ): if self . is_rpan_broadcast ( submission . url ): return await self . submission_to_broadcast ( submission ) return None get_top_broadcasts ( self , time_period = None ) async Gets the top broadcast on each subreddit (from within a specific time period). Parameters: Name Type Description Default time_period str The time period from which you would like to get the top broadcasts for. None Returns: Type Description tuple A tuple of the top broadcasts in each subreddit and the time period used. Source code in pyrpan\\client.py async def get_top_broadcasts ( self , time_period : str = None ) -> tuple : \"\"\" Gets the top broadcast on each subreddit (from within a specific time period). Parameters ---------- time_period : str The time period from which you would like to get the top broadcasts for. Returns ------- tuple A tuple of the top broadcasts in each subreddit and the time period used. \"\"\" allowed_time_periods = [ \"hour\" , \"day\" , \"week\" , \"month\" , \"year\" , \"all\" , ] if time_period : time_period = time_period . lower () if time_period not in allowed_time_periods : time_period = \"week\" if time_period in self . top_broadcasts_cache : return self . top_broadcasts_cache [ time_period ], time_period else : top_broadcasts = {} for subreddit in constants . RPAN_SUBREDDITS : subreddit = await self . reddit . subreddit ( subreddit ) async for submission in subreddit . search ( 'flair_name:\"Broadcast\"' , sort = \"top\" , time_filter = time_period , limit = 1 , ): top_broadcasts [ subreddit ] = submission self . top_broadcasts_cache [ time_period ] = top_broadcasts return top_broadcasts , time_period get_viewer_subreddits ( self ) async Gets a list of the recommended viewer RPAN subreddits. Returns: Type Description list The list of viewer subreddits. Source code in pyrpan\\client.py async def get_viewer_subreddits ( self ) -> list : \"\"\" Gets a list of the recommended viewer RPAN subreddits. Returns ------- list The list of viewer subreddits. \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/recommended_viewer_subreddits\" ) return data [ \"data\" ] is_rpan_broadcast ( self , link ) Checks if a link is a valid RPAN broadcast. Parameters: Name Type Description Default link str The link to check. required Returns: Type Description bool If the link is a valid RPAN broadcast. Source code in pyrpan\\client.py def is_rpan_broadcast ( self , link : str ) -> bool : \"\"\" Checks if a link is a valid RPAN broadcast. Parameters ---------- link : str The link to check. Returns ------- bool If the link is a valid RPAN broadcast. \"\"\" if \"reddit.com/rpan/\" in link : return True else : return False submission_to_broadcast ( self , submission ) async Turns a PRAW submission into a broadcast class. Parameters: Name Type Description Default submission Submission The submission to turn into a broadcast class. required Returns: Type Description Optional[pyrpan.models.Broadcast] The broadcast class. Source code in pyrpan\\client.py async def submission_to_broadcast ( self , submission : Submission ) -> Optional [ Broadcast ]: \"\"\" Turns a PRAW submission into a broadcast class. Parameters ---------- submission : str The submission to turn into a broadcast class. Returns ------- Broadcast The broadcast class. \"\"\" return Broadcast ( payload = { \"post\" : { \"id\" : submission . fullname , \"title\" : submission . title , \"url\" : submission . url , \"authorInfo\" : { \"name\" : submission . author . name }, \"subreddit\" : { \"name\" : submission . subreddit . display_name }, }, \"stream\" : { \"state\" : \"IS_LIVE\" , # TODO: Switch stream state \"publish_at\" : submission . created_utc , }, } ) models Broadcast Source code in pyrpan\\models.py class Broadcast : def __init__ ( self , payload : dict ) -> None : \"\"\" The broadcast class containing most of the information about a broadcast. Attributes ---------- id : str The ID of the broadcast. title : str The title of the broadcast. url : str The URL of the broadcast. thumbnail : str The URL of the thumbnail of the broadcast. score : int The total score of the broadcast. comment_count : int The total number of comments on the broadcast. created : int The timestamp of when the broadcast was created. author_name : str The username of the author of the broadcast (Returns 'u/[deleted]' if username is not found). subreddit_name : str The name of the subreddit the broadcast is in. published_at : int The timestamp of when the broadcast was started. upvotes : int The total number of upvotes on the broadcast. downvotes : int The total number of downvotes on the broadcast. is_first_broadcast : bool If the broadcast is the author's first broadcast. chat_disabled : bool If the chat is disabled for the broadcast. broadcast_time : str The current running time of the broadcast. estimated_remaining_time : str The estimated remaining time of the broadcast. is_live : bool If the broadcast is currently live. rank : int The rank of the broadcast. global_rank : int The global rank of the broadcast. subreddit_rank : int The rank of the broadcast in the subreddit. total_streams : int The total number of streams in the subreddit. unique_watchers : int The number of unique watchers of the broadcast. continuous_watchers : int The number of continuous watchers of the broadcast. total_continuous_watchers : int The total number of continuous watchers of the broadcast. \"\"\" self . id = payload [ \"post\" ][ \"id\" ] self . title = payload [ \"post\" ][ \"title\" ] self . url = payload [ \"post\" ][ \"url\" ] self . score = payload [ \"post\" ][ \"score\" ] self . comment_count = payload [ \"post\" ][ \"comment_count\" ] if payload [ \"post\" ][ \"authorInfo\" ]: self . author_name = payload [ \"post\" ][ \"authorInfo\" ][ \"name\" ] else : self . author_name = \"[deleted]\" self . subreddit_name = payload [ \"post\" ][ \"subreddit\" ][ \"name\" ] self . published_at = payload [ \"stream\" ][ \"publish_at\" ] self . upvotes = payload [ \"upvotes\" ] self . downvotes = payload [ \"downvotes\" ] self . is_first_broadcast = payload [ \"is_first_broadcast\" ] self . chat_disabled = payload [ \"chat_disabled\" ] self . broadcast_time = payload [ \"broadcast_time\" ] self . estimated_remaining_time = payload [ \"estimated_remaining_time\" ] if payload [ \"stream\" ][ \"state\" ] == \"IS_LIVE\" : self . is_live = True else : self . is_live = False self . rank = payload [ \"rank\" ] self . global_rank = payload [ \"global_rank\" ] self . subreddit_rank = payload [ \"rank_in_subreddit\" ] self . total_streams = payload [ \"total_streams\" ] self . unique_watchers = payload [ \"unique_watchers\" ] self . continuous_watchers = payload [ \"continuous_watchers\" ] self . total_continuous_watchers = payload [ \"total_continuous_watchers\" ] self . thumbnail = payload [ \"stream\" ][ \"thumbnail\" ] def __repr__ ( self ) -> str : return f \"Broadcast( { self . id } )\" __init__ ( self , payload ) special The broadcast class containing most of the information about a broadcast. Attributes: Name Type Description id str The ID of the broadcast. title str The title of the broadcast. url str The URL of the broadcast. thumbnail str The URL of the thumbnail of the broadcast. score int The total score of the broadcast. comment_count int The total number of comments on the broadcast. created int The timestamp of when the broadcast was created. author_name str The username of the author of the broadcast (Returns 'u/[deleted]' if username is not found). subreddit_name str The name of the subreddit the broadcast is in. published_at int The timestamp of when the broadcast was started. upvotes int The total number of upvotes on the broadcast. downvotes int The total number of downvotes on the broadcast. is_first_broadcast bool If the broadcast is the author's first broadcast. chat_disabled bool If the chat is disabled for the broadcast. broadcast_time str The current running time of the broadcast. estimated_remaining_time str The estimated remaining time of the broadcast. is_live bool If the broadcast is currently live. rank int The rank of the broadcast. global_rank int The global rank of the broadcast. subreddit_rank int The rank of the broadcast in the subreddit. total_streams int The total number of streams in the subreddit. unique_watchers int The number of unique watchers of the broadcast. continuous_watchers int The number of continuous watchers of the broadcast. total_continuous_watchers int The total number of continuous watchers of the broadcast. Source code in pyrpan\\models.py def __init__ ( self , payload : dict ) -> None : \"\"\" The broadcast class containing most of the information about a broadcast. Attributes ---------- id : str The ID of the broadcast. title : str The title of the broadcast. url : str The URL of the broadcast. thumbnail : str The URL of the thumbnail of the broadcast. score : int The total score of the broadcast. comment_count : int The total number of comments on the broadcast. created : int The timestamp of when the broadcast was created. author_name : str The username of the author of the broadcast (Returns 'u/[deleted]' if username is not found). subreddit_name : str The name of the subreddit the broadcast is in. published_at : int The timestamp of when the broadcast was started. upvotes : int The total number of upvotes on the broadcast. downvotes : int The total number of downvotes on the broadcast. is_first_broadcast : bool If the broadcast is the author's first broadcast. chat_disabled : bool If the chat is disabled for the broadcast. broadcast_time : str The current running time of the broadcast. estimated_remaining_time : str The estimated remaining time of the broadcast. is_live : bool If the broadcast is currently live. rank : int The rank of the broadcast. global_rank : int The global rank of the broadcast. subreddit_rank : int The rank of the broadcast in the subreddit. total_streams : int The total number of streams in the subreddit. unique_watchers : int The number of unique watchers of the broadcast. continuous_watchers : int The number of continuous watchers of the broadcast. total_continuous_watchers : int The total number of continuous watchers of the broadcast. \"\"\" self . id = payload [ \"post\" ][ \"id\" ] self . title = payload [ \"post\" ][ \"title\" ] self . url = payload [ \"post\" ][ \"url\" ] self . score = payload [ \"post\" ][ \"score\" ] self . comment_count = payload [ \"post\" ][ \"comment_count\" ] if payload [ \"post\" ][ \"authorInfo\" ]: self . author_name = payload [ \"post\" ][ \"authorInfo\" ][ \"name\" ] else : self . author_name = \"[deleted]\" self . subreddit_name = payload [ \"post\" ][ \"subreddit\" ][ \"name\" ] self . published_at = payload [ \"stream\" ][ \"publish_at\" ] self . upvotes = payload [ \"upvotes\" ] self . downvotes = payload [ \"downvotes\" ] self . is_first_broadcast = payload [ \"is_first_broadcast\" ] self . chat_disabled = payload [ \"chat_disabled\" ] self . broadcast_time = payload [ \"broadcast_time\" ] self . estimated_remaining_time = payload [ \"estimated_remaining_time\" ] if payload [ \"stream\" ][ \"state\" ] == \"IS_LIVE\" : self . is_live = True else : self . is_live = False self . rank = payload [ \"rank\" ] self . global_rank = payload [ \"global_rank\" ] self . subreddit_rank = payload [ \"rank_in_subreddit\" ] self . total_streams = payload [ \"total_streams\" ] self . unique_watchers = payload [ \"unique_watchers\" ] self . continuous_watchers = payload [ \"continuous_watchers\" ] self . total_continuous_watchers = payload [ \"total_continuous_watchers\" ] self . thumbnail = payload [ \"stream\" ][ \"thumbnail\" ] Broadcasts Source code in pyrpan\\models.py class Broadcasts : def __init__ ( self , contents : list = None ) -> None : \"\"\" The broadcast list class containing all of the broadcasts fetched from the API.\\ Attributes ---------- broadcasts : list The list of broadcasts. \"\"\" self . broadcasts = [] if contents : self . broadcasts = contents def top_broadcast ( self , subreddit : str = None ) -> Union [ Broadcast , None ]: \"\"\" Gets the top broadcast. Parameters ---------- subreddit : str Optional paramater to find the top broadcast on a specific subreddit. Returns ------- Broadcast The top broadcast. \"\"\" if not len ( self . broadcasts ): return None if subreddit is None : return self . broadcasts [ 0 ] else : subreddit = subreddit . lower () for broadcast in self . broadcasts : if broadcast . subreddit_name . lower () == subreddit : return broadcast return None def has_broadcast ( self , id : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast with a specified ID. Parameters ---------- id : str The ID of the broadcast. Returns ------- Broadcast If the broadcast list contains a broadcast with the specified ID. \"\"\" for broadcast in self . broadcasts : if broadcast . id == id : return broadcast return False def has_streamer ( self , name : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast from a specified user. Parameters ---------- name : str The streamer to search for. Returns ------- Broadcast If the broadcast list contains a broadcast from the specified user. \"\"\" name = name . lower () for broadcast in self . broadcasts : if broadcast . author_name . lower () == name : return broadcast return False def __repr__ ( self ) -> str : return f \"Broadcasts( { ', ' . join ( repr ( broadcast ) for broadcast in self . broadcasts ) } )\" __init__ ( self , contents = None ) special The broadcast list class containing all of the broadcasts fetched from the API. Attributes: Name Type Description broadcasts list The list of broadcasts. Source code in pyrpan\\models.py def __init__ ( self , contents : list = None ) -> None : \"\"\" The broadcast list class containing all of the broadcasts fetched from the API.\\ Attributes ---------- broadcasts : list The list of broadcasts. \"\"\" self . broadcasts = [] if contents : self . broadcasts = contents has_broadcast ( self , id ) Checks if the broadcast list contains a broadcast with a specified ID. Parameters: Name Type Description Default id str The ID of the broadcast. required Returns: Type Description Union[pyrpan.models.Broadcast, bool] If the broadcast list contains a broadcast with the specified ID. Source code in pyrpan\\models.py def has_broadcast ( self , id : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast with a specified ID. Parameters ---------- id : str The ID of the broadcast. Returns ------- Broadcast If the broadcast list contains a broadcast with the specified ID. \"\"\" for broadcast in self . broadcasts : if broadcast . id == id : return broadcast return False has_streamer ( self , name ) Checks if the broadcast list contains a broadcast from a specified user. Parameters: Name Type Description Default name str The streamer to search for. required Returns: Type Description Union[pyrpan.models.Broadcast, bool] If the broadcast list contains a broadcast from the specified user. Source code in pyrpan\\models.py def has_streamer ( self , name : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast from a specified user. Parameters ---------- name : str The streamer to search for. Returns ------- Broadcast If the broadcast list contains a broadcast from the specified user. \"\"\" name = name . lower () for broadcast in self . broadcasts : if broadcast . author_name . lower () == name : return broadcast return False top_broadcast ( self , subreddit = None ) Gets the top broadcast. Parameters: Name Type Description Default subreddit str Optional paramater to find the top broadcast on a specific subreddit. None Returns: Type Description Optional[pyrpan.models.Broadcast] The top broadcast. Source code in pyrpan\\models.py def top_broadcast ( self , subreddit : str = None ) -> Union [ Broadcast , None ]: \"\"\" Gets the top broadcast. Parameters ---------- subreddit : str Optional paramater to find the top broadcast on a specific subreddit. Returns ------- Broadcast The top broadcast. \"\"\" if not len ( self . broadcasts ): return None if subreddit is None : return self . broadcasts [ 0 ] else : subreddit = subreddit . lower () for broadcast in self . broadcasts : if broadcast . subreddit_name . lower () == subreddit : return broadcast return None","title":"Code Reference"},{"location":"code-reference/#code-reference","text":"","title":"Code Reference"},{"location":"code-reference/#pyrpan.client","text":"","title":"client"},{"location":"code-reference/#pyrpan.client.PyRPAN","text":"Client class for the PyRPAN API Wrapper. Attributes: Name Type Description reddit str The Reddit instance to use to access the Reddit API. top_broadcasts_cache ExpiringDict A cache of the top broadcasts. api_url str URL to access the RPAN API. session aiohttp.ClientSession For creating client session and to make requests. Source code in pyrpan\\client.py class PyRPAN : \"\"\" Client class for the PyRPAN API Wrapper. Attributes ---------- reddit : str The Reddit instance to use to access the Reddit API. top_broadcasts_cache : ExpiringDict A cache of the top broadcasts. api_url : str URL to access the RPAN API. session : aiohttp.ClientSession For creating client session and to make requests. \"\"\" def __init__ ( self , client_id : str , client_secret : str ) -> None : \"\"\" Construct the PyRPAN wrapper. Parameters ---------- client_id : str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. client_secret : str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. \"\"\" self . api_url = \"https://strapi.reddit.com\" self . top_broadcasts_cache = ExpiringDict ( max_len = 3 , max_age_seconds = 300 ) self . reddit = Reddit ( client_id = client_id , client_secret = client_secret , user_agent = \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , ) self . _session = None self . _lock = asyncio . Lock () async def close ( self ) -> None : \"\"\"Close the client session.\"\"\" if self . _session is not None : await self . _session . close () async def fetch ( self , method : str , route : str , * , headers : Optional [ dict ] = None , data : Optional [ dict ] = None ) -> Optional [ dict ]: \"\"\" Fetching a response from the API Parameters ---------- route : str The API route you want to make a call to headers : dict Headers for the API call, Defaults to None data : dict Data for the API call, Defaults to None Returns ------- Optional[dict] The response from the API. \"\"\" if headers is None : headers = {} headers = { \"User-Agent\" : \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , \"Cache-Control\" : \"no-cache\" , ** headers , } if not self . _session : self . _session = aiohttp . ClientSession () async with self . _lock : async with self . _session . request ( method = method , url = self . api_url + route , headers = headers , data = data ) as res : # Handle status codes if res . status in [ 200 , 201 , 204 ]: data = await res . json () if res . status == 400 : raise InvalidRequest ( \"Bad request - Request performed was invalid.\" ) if res . status == 429 : raise InvalidRequest ( \"Too many requests - Slow down your requests.\" ) if res . status == 500 : raise InvalidRequest ( \"Internal Server Error - Something went wrong.\" ) return data async def get_viewer_subreddits ( self ) -> list : \"\"\" Gets a list of the recommended viewer RPAN subreddits. Returns ------- list The list of viewer subreddits. \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/recommended_viewer_subreddits\" ) return data [ \"data\" ] async def get_broadcast ( self , id : str ) -> Optional [ Broadcast ]: \"\"\" Gets a broadcast by ID. Parameters ---------- id : str ID of the broadcast you want to fetch. Returns ------- Broadcast The retrived broadcast or None. \"\"\" data = await self . fetch ( method = \"GET\" , route = f \"/broadcasts/ { id } \" ) if data [ \"status\" ] == \"success\" : payload = data [ \"data\" ] return Broadcast ( payload = payload ) else : return None async def get_broadcasts ( self ) -> Optional [ Broadcasts ]: \"\"\" Fetches all the currently active broadcasts. Returns ------- Broadcasts The retrived broadcasts or None. \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/broadcasts\" ) if data [ \"status\" ] == \"success\" : broadcasts = [] if len ( data [ \"data\" ]): for broadcast in data [ \"data\" ]: payload = broadcast broadcasts . append ( Broadcast ( payload = payload )) return Broadcasts ( contents = broadcasts ) else : return None async def get_last_broadcast ( self , username : str ) -> Optional [ Broadcast ]: \"\"\" Gets the last broadcast of a user. Parameters ---------- username : str The username of the user you want to get the last broadcast for. Returns ------- Broadcast The found last broadcast or None. \"\"\" user = await self . reddit . redditor ( username ) async for submission in user . submissions . new ( limit = 25 ): if self . is_rpan_broadcast ( submission . url ): return await self . submission_to_broadcast ( submission ) return None async def get_top_broadcasts ( self , time_period : str = None ) -> tuple : \"\"\" Gets the top broadcast on each subreddit (from within a specific time period). Parameters ---------- time_period : str The time period from which you would like to get the top broadcasts for. Returns ------- tuple A tuple of the top broadcasts in each subreddit and the time period used. \"\"\" allowed_time_periods = [ \"hour\" , \"day\" , \"week\" , \"month\" , \"year\" , \"all\" , ] if time_period : time_period = time_period . lower () if time_period not in allowed_time_periods : time_period = \"week\" if time_period in self . top_broadcasts_cache : return self . top_broadcasts_cache [ time_period ], time_period else : top_broadcasts = {} for subreddit in constants . RPAN_SUBREDDITS : subreddit = await self . reddit . subreddit ( subreddit ) async for submission in subreddit . search ( 'flair_name:\"Broadcast\"' , sort = \"top\" , time_filter = time_period , limit = 1 , ): top_broadcasts [ subreddit ] = submission self . top_broadcasts_cache [ time_period ] = top_broadcasts return top_broadcasts , time_period async def submission_to_broadcast ( self , submission : Submission ) -> Optional [ Broadcast ]: \"\"\" Turns a PRAW submission into a broadcast class. Parameters ---------- submission : str The submission to turn into a broadcast class. Returns ------- Broadcast The broadcast class. \"\"\" return Broadcast ( payload = { \"post\" : { \"id\" : submission . fullname , \"title\" : submission . title , \"url\" : submission . url , \"authorInfo\" : { \"name\" : submission . author . name }, \"subreddit\" : { \"name\" : submission . subreddit . display_name }, }, \"stream\" : { \"state\" : \"IS_LIVE\" , # TODO: Switch stream state \"publish_at\" : submission . created_utc , }, } ) def format_broadcast_timestamp ( self , timestamp : int ) -> str : \"\"\" Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters ---------- timestamp : int The timestamp to format. Returns ------- str The timestamp in a set format. \"\"\" return datetime . fromtimestamp ( int ( timestamp ), tz = timezone . utc ) def is_rpan_broadcast ( self , link : str ) -> bool : \"\"\" Checks if a link is a valid RPAN broadcast. Parameters ---------- link : str The link to check. Returns ------- bool If the link is a valid RPAN broadcast. \"\"\" if \"reddit.com/rpan/\" in link : return True else : return False","title":"PyRPAN"},{"location":"code-reference/#pyrpan.client.PyRPAN.__init__","text":"Construct the PyRPAN wrapper. Parameters: Name Type Description Default client_id str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. required client_secret str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. required Source code in pyrpan\\client.py def __init__ ( self , client_id : str , client_secret : str ) -> None : \"\"\" Construct the PyRPAN wrapper. Parameters ---------- client_id : str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. client_secret : str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. \"\"\" self . api_url = \"https://strapi.reddit.com\" self . top_broadcasts_cache = ExpiringDict ( max_len = 3 , max_age_seconds = 300 ) self . reddit = Reddit ( client_id = client_id , client_secret = client_secret , user_agent = \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , ) self . _session = None self . _lock = asyncio . Lock ()","title":"__init__()"},{"location":"code-reference/#pyrpan.client.PyRPAN.close","text":"Close the client session. Source code in pyrpan\\client.py async def close ( self ) -> None : \"\"\"Close the client session.\"\"\" if self . _session is not None : await self . _session . close ()","title":"close()"},{"location":"code-reference/#pyrpan.client.PyRPAN.fetch","text":"Fetching a response from the API Parameters: Name Type Description Default route str The API route you want to make a call to required headers Optional[dict] Headers for the API call, Defaults to None None data Optional[dict] Data for the API call, Defaults to None None Returns: Type Description Optional[dict] The response from the API. Source code in pyrpan\\client.py async def fetch ( self , method : str , route : str , * , headers : Optional [ dict ] = None , data : Optional [ dict ] = None ) -> Optional [ dict ]: \"\"\" Fetching a response from the API Parameters ---------- route : str The API route you want to make a call to headers : dict Headers for the API call, Defaults to None data : dict Data for the API call, Defaults to None Returns ------- Optional[dict] The response from the API. \"\"\" if headers is None : headers = {} headers = { \"User-Agent\" : \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , \"Cache-Control\" : \"no-cache\" , ** headers , } if not self . _session : self . _session = aiohttp . ClientSession () async with self . _lock : async with self . _session . request ( method = method , url = self . api_url + route , headers = headers , data = data ) as res : # Handle status codes if res . status in [ 200 , 201 , 204 ]: data = await res . json () if res . status == 400 : raise InvalidRequest ( \"Bad request - Request performed was invalid.\" ) if res . status == 429 : raise InvalidRequest ( \"Too many requests - Slow down your requests.\" ) if res . status == 500 : raise InvalidRequest ( \"Internal Server Error - Something went wrong.\" ) return data","title":"fetch()"},{"location":"code-reference/#pyrpan.client.PyRPAN.format_broadcast_timestamp","text":"Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters: Name Type Description Default timestamp int The timestamp to format. required Returns: Type Description str The timestamp in a set format. Source code in pyrpan\\client.py def format_broadcast_timestamp ( self , timestamp : int ) -> str : \"\"\" Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters ---------- timestamp : int The timestamp to format. Returns ------- str The timestamp in a set format. \"\"\" return datetime . fromtimestamp ( int ( timestamp ), tz = timezone . utc )","title":"format_broadcast_timestamp()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_broadcast","text":"Gets a broadcast by ID. Parameters: Name Type Description Default id str ID of the broadcast you want to fetch. required Returns: Type Description Optional[pyrpan.models.Broadcast] The retrived broadcast or None. Source code in pyrpan\\client.py async def get_broadcast ( self , id : str ) -> Optional [ Broadcast ]: \"\"\" Gets a broadcast by ID. Parameters ---------- id : str ID of the broadcast you want to fetch. Returns ------- Broadcast The retrived broadcast or None. \"\"\" data = await self . fetch ( method = \"GET\" , route = f \"/broadcasts/ { id } \" ) if data [ \"status\" ] == \"success\" : payload = data [ \"data\" ] return Broadcast ( payload = payload ) else : return None","title":"get_broadcast()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_broadcasts","text":"Fetches all the currently active broadcasts. Returns: Type Description Optional[pyrpan.models.Broadcasts] The retrived broadcasts or None. Source code in pyrpan\\client.py async def get_broadcasts ( self ) -> Optional [ Broadcasts ]: \"\"\" Fetches all the currently active broadcasts. Returns ------- Broadcasts The retrived broadcasts or None. \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/broadcasts\" ) if data [ \"status\" ] == \"success\" : broadcasts = [] if len ( data [ \"data\" ]): for broadcast in data [ \"data\" ]: payload = broadcast broadcasts . append ( Broadcast ( payload = payload )) return Broadcasts ( contents = broadcasts ) else : return None","title":"get_broadcasts()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_last_broadcast","text":"Gets the last broadcast of a user. Parameters: Name Type Description Default username str The username of the user you want to get the last broadcast for. required Returns: Type Description Optional[pyrpan.models.Broadcast] The found last broadcast or None. Source code in pyrpan\\client.py async def get_last_broadcast ( self , username : str ) -> Optional [ Broadcast ]: \"\"\" Gets the last broadcast of a user. Parameters ---------- username : str The username of the user you want to get the last broadcast for. Returns ------- Broadcast The found last broadcast or None. \"\"\" user = await self . reddit . redditor ( username ) async for submission in user . submissions . new ( limit = 25 ): if self . is_rpan_broadcast ( submission . url ): return await self . submission_to_broadcast ( submission ) return None","title":"get_last_broadcast()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_top_broadcasts","text":"Gets the top broadcast on each subreddit (from within a specific time period). Parameters: Name Type Description Default time_period str The time period from which you would like to get the top broadcasts for. None Returns: Type Description tuple A tuple of the top broadcasts in each subreddit and the time period used. Source code in pyrpan\\client.py async def get_top_broadcasts ( self , time_period : str = None ) -> tuple : \"\"\" Gets the top broadcast on each subreddit (from within a specific time period). Parameters ---------- time_period : str The time period from which you would like to get the top broadcasts for. Returns ------- tuple A tuple of the top broadcasts in each subreddit and the time period used. \"\"\" allowed_time_periods = [ \"hour\" , \"day\" , \"week\" , \"month\" , \"year\" , \"all\" , ] if time_period : time_period = time_period . lower () if time_period not in allowed_time_periods : time_period = \"week\" if time_period in self . top_broadcasts_cache : return self . top_broadcasts_cache [ time_period ], time_period else : top_broadcasts = {} for subreddit in constants . RPAN_SUBREDDITS : subreddit = await self . reddit . subreddit ( subreddit ) async for submission in subreddit . search ( 'flair_name:\"Broadcast\"' , sort = \"top\" , time_filter = time_period , limit = 1 , ): top_broadcasts [ subreddit ] = submission self . top_broadcasts_cache [ time_period ] = top_broadcasts return top_broadcasts , time_period","title":"get_top_broadcasts()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_viewer_subreddits","text":"Gets a list of the recommended viewer RPAN subreddits. Returns: Type Description list The list of viewer subreddits. Source code in pyrpan\\client.py async def get_viewer_subreddits ( self ) -> list : \"\"\" Gets a list of the recommended viewer RPAN subreddits. Returns ------- list The list of viewer subreddits. \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/recommended_viewer_subreddits\" ) return data [ \"data\" ]","title":"get_viewer_subreddits()"},{"location":"code-reference/#pyrpan.client.PyRPAN.is_rpan_broadcast","text":"Checks if a link is a valid RPAN broadcast. Parameters: Name Type Description Default link str The link to check. required Returns: Type Description bool If the link is a valid RPAN broadcast. Source code in pyrpan\\client.py def is_rpan_broadcast ( self , link : str ) -> bool : \"\"\" Checks if a link is a valid RPAN broadcast. Parameters ---------- link : str The link to check. Returns ------- bool If the link is a valid RPAN broadcast. \"\"\" if \"reddit.com/rpan/\" in link : return True else : return False","title":"is_rpan_broadcast()"},{"location":"code-reference/#pyrpan.client.PyRPAN.submission_to_broadcast","text":"Turns a PRAW submission into a broadcast class. Parameters: Name Type Description Default submission Submission The submission to turn into a broadcast class. required Returns: Type Description Optional[pyrpan.models.Broadcast] The broadcast class. Source code in pyrpan\\client.py async def submission_to_broadcast ( self , submission : Submission ) -> Optional [ Broadcast ]: \"\"\" Turns a PRAW submission into a broadcast class. Parameters ---------- submission : str The submission to turn into a broadcast class. Returns ------- Broadcast The broadcast class. \"\"\" return Broadcast ( payload = { \"post\" : { \"id\" : submission . fullname , \"title\" : submission . title , \"url\" : submission . url , \"authorInfo\" : { \"name\" : submission . author . name }, \"subreddit\" : { \"name\" : submission . subreddit . display_name }, }, \"stream\" : { \"state\" : \"IS_LIVE\" , # TODO: Switch stream state \"publish_at\" : submission . created_utc , }, } )","title":"submission_to_broadcast()"},{"location":"code-reference/#pyrpan.models","text":"","title":"models"},{"location":"code-reference/#pyrpan.models.Broadcast","text":"Source code in pyrpan\\models.py class Broadcast : def __init__ ( self , payload : dict ) -> None : \"\"\" The broadcast class containing most of the information about a broadcast. Attributes ---------- id : str The ID of the broadcast. title : str The title of the broadcast. url : str The URL of the broadcast. thumbnail : str The URL of the thumbnail of the broadcast. score : int The total score of the broadcast. comment_count : int The total number of comments on the broadcast. created : int The timestamp of when the broadcast was created. author_name : str The username of the author of the broadcast (Returns 'u/[deleted]' if username is not found). subreddit_name : str The name of the subreddit the broadcast is in. published_at : int The timestamp of when the broadcast was started. upvotes : int The total number of upvotes on the broadcast. downvotes : int The total number of downvotes on the broadcast. is_first_broadcast : bool If the broadcast is the author's first broadcast. chat_disabled : bool If the chat is disabled for the broadcast. broadcast_time : str The current running time of the broadcast. estimated_remaining_time : str The estimated remaining time of the broadcast. is_live : bool If the broadcast is currently live. rank : int The rank of the broadcast. global_rank : int The global rank of the broadcast. subreddit_rank : int The rank of the broadcast in the subreddit. total_streams : int The total number of streams in the subreddit. unique_watchers : int The number of unique watchers of the broadcast. continuous_watchers : int The number of continuous watchers of the broadcast. total_continuous_watchers : int The total number of continuous watchers of the broadcast. \"\"\" self . id = payload [ \"post\" ][ \"id\" ] self . title = payload [ \"post\" ][ \"title\" ] self . url = payload [ \"post\" ][ \"url\" ] self . score = payload [ \"post\" ][ \"score\" ] self . comment_count = payload [ \"post\" ][ \"comment_count\" ] if payload [ \"post\" ][ \"authorInfo\" ]: self . author_name = payload [ \"post\" ][ \"authorInfo\" ][ \"name\" ] else : self . author_name = \"[deleted]\" self . subreddit_name = payload [ \"post\" ][ \"subreddit\" ][ \"name\" ] self . published_at = payload [ \"stream\" ][ \"publish_at\" ] self . upvotes = payload [ \"upvotes\" ] self . downvotes = payload [ \"downvotes\" ] self . is_first_broadcast = payload [ \"is_first_broadcast\" ] self . chat_disabled = payload [ \"chat_disabled\" ] self . broadcast_time = payload [ \"broadcast_time\" ] self . estimated_remaining_time = payload [ \"estimated_remaining_time\" ] if payload [ \"stream\" ][ \"state\" ] == \"IS_LIVE\" : self . is_live = True else : self . is_live = False self . rank = payload [ \"rank\" ] self . global_rank = payload [ \"global_rank\" ] self . subreddit_rank = payload [ \"rank_in_subreddit\" ] self . total_streams = payload [ \"total_streams\" ] self . unique_watchers = payload [ \"unique_watchers\" ] self . continuous_watchers = payload [ \"continuous_watchers\" ] self . total_continuous_watchers = payload [ \"total_continuous_watchers\" ] self . thumbnail = payload [ \"stream\" ][ \"thumbnail\" ] def __repr__ ( self ) -> str : return f \"Broadcast( { self . id } )\"","title":"Broadcast"},{"location":"code-reference/#pyrpan.models.Broadcast.__init__","text":"The broadcast class containing most of the information about a broadcast. Attributes: Name Type Description id str The ID of the broadcast. title str The title of the broadcast. url str The URL of the broadcast. thumbnail str The URL of the thumbnail of the broadcast. score int The total score of the broadcast. comment_count int The total number of comments on the broadcast. created int The timestamp of when the broadcast was created. author_name str The username of the author of the broadcast (Returns 'u/[deleted]' if username is not found). subreddit_name str The name of the subreddit the broadcast is in. published_at int The timestamp of when the broadcast was started. upvotes int The total number of upvotes on the broadcast. downvotes int The total number of downvotes on the broadcast. is_first_broadcast bool If the broadcast is the author's first broadcast. chat_disabled bool If the chat is disabled for the broadcast. broadcast_time str The current running time of the broadcast. estimated_remaining_time str The estimated remaining time of the broadcast. is_live bool If the broadcast is currently live. rank int The rank of the broadcast. global_rank int The global rank of the broadcast. subreddit_rank int The rank of the broadcast in the subreddit. total_streams int The total number of streams in the subreddit. unique_watchers int The number of unique watchers of the broadcast. continuous_watchers int The number of continuous watchers of the broadcast. total_continuous_watchers int The total number of continuous watchers of the broadcast. Source code in pyrpan\\models.py def __init__ ( self , payload : dict ) -> None : \"\"\" The broadcast class containing most of the information about a broadcast. Attributes ---------- id : str The ID of the broadcast. title : str The title of the broadcast. url : str The URL of the broadcast. thumbnail : str The URL of the thumbnail of the broadcast. score : int The total score of the broadcast. comment_count : int The total number of comments on the broadcast. created : int The timestamp of when the broadcast was created. author_name : str The username of the author of the broadcast (Returns 'u/[deleted]' if username is not found). subreddit_name : str The name of the subreddit the broadcast is in. published_at : int The timestamp of when the broadcast was started. upvotes : int The total number of upvotes on the broadcast. downvotes : int The total number of downvotes on the broadcast. is_first_broadcast : bool If the broadcast is the author's first broadcast. chat_disabled : bool If the chat is disabled for the broadcast. broadcast_time : str The current running time of the broadcast. estimated_remaining_time : str The estimated remaining time of the broadcast. is_live : bool If the broadcast is currently live. rank : int The rank of the broadcast. global_rank : int The global rank of the broadcast. subreddit_rank : int The rank of the broadcast in the subreddit. total_streams : int The total number of streams in the subreddit. unique_watchers : int The number of unique watchers of the broadcast. continuous_watchers : int The number of continuous watchers of the broadcast. total_continuous_watchers : int The total number of continuous watchers of the broadcast. \"\"\" self . id = payload [ \"post\" ][ \"id\" ] self . title = payload [ \"post\" ][ \"title\" ] self . url = payload [ \"post\" ][ \"url\" ] self . score = payload [ \"post\" ][ \"score\" ] self . comment_count = payload [ \"post\" ][ \"comment_count\" ] if payload [ \"post\" ][ \"authorInfo\" ]: self . author_name = payload [ \"post\" ][ \"authorInfo\" ][ \"name\" ] else : self . author_name = \"[deleted]\" self . subreddit_name = payload [ \"post\" ][ \"subreddit\" ][ \"name\" ] self . published_at = payload [ \"stream\" ][ \"publish_at\" ] self . upvotes = payload [ \"upvotes\" ] self . downvotes = payload [ \"downvotes\" ] self . is_first_broadcast = payload [ \"is_first_broadcast\" ] self . chat_disabled = payload [ \"chat_disabled\" ] self . broadcast_time = payload [ \"broadcast_time\" ] self . estimated_remaining_time = payload [ \"estimated_remaining_time\" ] if payload [ \"stream\" ][ \"state\" ] == \"IS_LIVE\" : self . is_live = True else : self . is_live = False self . rank = payload [ \"rank\" ] self . global_rank = payload [ \"global_rank\" ] self . subreddit_rank = payload [ \"rank_in_subreddit\" ] self . total_streams = payload [ \"total_streams\" ] self . unique_watchers = payload [ \"unique_watchers\" ] self . continuous_watchers = payload [ \"continuous_watchers\" ] self . total_continuous_watchers = payload [ \"total_continuous_watchers\" ] self . thumbnail = payload [ \"stream\" ][ \"thumbnail\" ]","title":"__init__()"},{"location":"code-reference/#pyrpan.models.Broadcasts","text":"Source code in pyrpan\\models.py class Broadcasts : def __init__ ( self , contents : list = None ) -> None : \"\"\" The broadcast list class containing all of the broadcasts fetched from the API.\\ Attributes ---------- broadcasts : list The list of broadcasts. \"\"\" self . broadcasts = [] if contents : self . broadcasts = contents def top_broadcast ( self , subreddit : str = None ) -> Union [ Broadcast , None ]: \"\"\" Gets the top broadcast. Parameters ---------- subreddit : str Optional paramater to find the top broadcast on a specific subreddit. Returns ------- Broadcast The top broadcast. \"\"\" if not len ( self . broadcasts ): return None if subreddit is None : return self . broadcasts [ 0 ] else : subreddit = subreddit . lower () for broadcast in self . broadcasts : if broadcast . subreddit_name . lower () == subreddit : return broadcast return None def has_broadcast ( self , id : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast with a specified ID. Parameters ---------- id : str The ID of the broadcast. Returns ------- Broadcast If the broadcast list contains a broadcast with the specified ID. \"\"\" for broadcast in self . broadcasts : if broadcast . id == id : return broadcast return False def has_streamer ( self , name : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast from a specified user. Parameters ---------- name : str The streamer to search for. Returns ------- Broadcast If the broadcast list contains a broadcast from the specified user. \"\"\" name = name . lower () for broadcast in self . broadcasts : if broadcast . author_name . lower () == name : return broadcast return False def __repr__ ( self ) -> str : return f \"Broadcasts( { ', ' . join ( repr ( broadcast ) for broadcast in self . broadcasts ) } )\"","title":"Broadcasts"},{"location":"code-reference/#pyrpan.models.Broadcasts.__init__","text":"The broadcast list class containing all of the broadcasts fetched from the API. Attributes: Name Type Description broadcasts list The list of broadcasts. Source code in pyrpan\\models.py def __init__ ( self , contents : list = None ) -> None : \"\"\" The broadcast list class containing all of the broadcasts fetched from the API.\\ Attributes ---------- broadcasts : list The list of broadcasts. \"\"\" self . broadcasts = [] if contents : self . broadcasts = contents","title":"__init__()"},{"location":"code-reference/#pyrpan.models.Broadcasts.has_broadcast","text":"Checks if the broadcast list contains a broadcast with a specified ID. Parameters: Name Type Description Default id str The ID of the broadcast. required Returns: Type Description Union[pyrpan.models.Broadcast, bool] If the broadcast list contains a broadcast with the specified ID. Source code in pyrpan\\models.py def has_broadcast ( self , id : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast with a specified ID. Parameters ---------- id : str The ID of the broadcast. Returns ------- Broadcast If the broadcast list contains a broadcast with the specified ID. \"\"\" for broadcast in self . broadcasts : if broadcast . id == id : return broadcast return False","title":"has_broadcast()"},{"location":"code-reference/#pyrpan.models.Broadcasts.has_streamer","text":"Checks if the broadcast list contains a broadcast from a specified user. Parameters: Name Type Description Default name str The streamer to search for. required Returns: Type Description Union[pyrpan.models.Broadcast, bool] If the broadcast list contains a broadcast from the specified user. Source code in pyrpan\\models.py def has_streamer ( self , name : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast from a specified user. Parameters ---------- name : str The streamer to search for. Returns ------- Broadcast If the broadcast list contains a broadcast from the specified user. \"\"\" name = name . lower () for broadcast in self . broadcasts : if broadcast . author_name . lower () == name : return broadcast return False","title":"has_streamer()"},{"location":"code-reference/#pyrpan.models.Broadcasts.top_broadcast","text":"Gets the top broadcast. Parameters: Name Type Description Default subreddit str Optional paramater to find the top broadcast on a specific subreddit. None Returns: Type Description Optional[pyrpan.models.Broadcast] The top broadcast. Source code in pyrpan\\models.py def top_broadcast ( self , subreddit : str = None ) -> Union [ Broadcast , None ]: \"\"\" Gets the top broadcast. Parameters ---------- subreddit : str Optional paramater to find the top broadcast on a specific subreddit. Returns ------- Broadcast The top broadcast. \"\"\" if not len ( self . broadcasts ): return None if subreddit is None : return self . broadcasts [ 0 ] else : subreddit = subreddit . lower () for broadcast in self . broadcasts : if broadcast . subreddit_name . lower () == subreddit : return broadcast return None","title":"top_broadcast()"},{"location":"installation/","text":"Installation To install PyRPAN, run the following command from the command line: pip install pyrpan To install the development version of PyRPAN, run the following command from the command line: pip install git+https://github.com/b1uejay27/PyRPAN.git","title":"Installation"},{"location":"installation/#installation","text":"To install PyRPAN, run the following command from the command line: pip install pyrpan To install the development version of PyRPAN, run the following command from the command line: pip install git+https://github.com/b1uejay27/PyRPAN.git","title":"Installation"}]}