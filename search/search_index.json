{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About PyRPAN is an async API wrapper made in Python for the Reddit Public Access Network (RPAN), which is Reddit's streaming service. Example import asyncio from pyrpan import PyRPAN rpan = PyRPAN(client_id='client id here', client_secret='client secret here') async def main(): broadcasts = await rpan.get_broadcast(id='stream id here') print(broadcast.url) await rpan.close() asyncio.run(main()) Links Source Code : github.com/b1uejay27/PyRPAN PyPi : pypi.org/project/PyRPAN Discord Server : discord.gg/DfBp4x4","title":"Home"},{"location":"#about","text":"PyRPAN is an async API wrapper made in Python for the Reddit Public Access Network (RPAN), which is Reddit's streaming service.","title":"About"},{"location":"#example","text":"import asyncio from pyrpan import PyRPAN rpan = PyRPAN(client_id='client id here', client_secret='client secret here') async def main(): broadcasts = await rpan.get_broadcast(id='stream id here') print(broadcast.url) await rpan.close() asyncio.run(main())","title":"Example"},{"location":"#links","text":"Source Code : github.com/b1uejay27/PyRPAN PyPi : pypi.org/project/PyRPAN Discord Server : discord.gg/DfBp4x4","title":"Links"},{"location":"code-reference/","text":"Code Reference client PyRPAN Client class for the PyRPAN API Wrapper. Attributes: Name Type Description reddit str The Reddit instance to use to access the Reddit API. top_broadcasts_cache ExpiringDict A cache of the top broadcasts. api_url str URL to access the RPAN API. session aiohttp.ClientSession For creating client session and to make requests. Source code in pyrpan\\client.py class PyRPAN : \"\"\" Client class for the PyRPAN API Wrapper. Attributes ---------- reddit : str The Reddit instance to use to access the Reddit API. top_broadcasts_cache : ExpiringDict A cache of the top broadcasts. api_url : str URL to access the RPAN API. session : aiohttp.ClientSession For creating client session and to make requests. \"\"\" def __init__ ( self , client_id : str , client_secret : str ) -> None : \"\"\" Construct the PyRPAN wrapper. Parameters ---------- client_id : str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. client_secret : str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. \"\"\" self . api_url = \"https://strapi.reddit.com\" self . top_broadcasts_cache = ExpiringDict ( max_len = 3 , max_age_seconds = 300 ) self . reddit = Reddit ( client_id = client_id , client_secret = client_secret , user_agent = \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , ) self . _session = None self . _lock = asyncio . Lock () async def close ( self ) -> None : \"\"\"Close the client session.\"\"\" if self . _session is not None : await self . _session . close () async def fetch ( self , method : str , route : str , * , headers : Optional [ dict ] = None , data : Optional [ dict ] = None ) -> Optional [ dict ]: \"\"\" Fetching a response from the API Parameters ---------- route : str The API route you want to make a call to headers : dict Headers for the API call, Defaults to None data : dict Data for the API call, Defaults to None Returns ------- Optional[dict] \"\"\" if headers is None : headers = {} headers = { \"User-Agent\" : \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , \"Cache-Control\" : \"no-cache\" , ** headers , } if not self . _session : self . _session = aiohttp . ClientSession () async with self . _lock : async with self . _session . request ( method = method , url = self . api_url + route , headers = headers , data = data ) as res : # Handle status codes if res . status in [ 200 , 201 , 204 ]: data = await res . json () if res . status == 400 : raise InvalidRequest ( \"Bad request - Request performed was invalid.\" ) if res . status == 429 : raise InvalidRequest ( \"Too many requests - Slow down your requests.\" ) if res . status == 500 : raise InvalidRequest ( \"Internal Server Error - Something went wrong.\" ) return data async def get_viewer_subreddits ( self ) -> list : \"\"\" Gets a list of the recommended viewer RPAN subreddits. Returns ------- list \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/recommended_viewer_subreddits\" ) return data [ \"data\" ] async def get_broadcast ( self , id : str ) -> Optional [ Broadcast ]: \"\"\" Gets a broadcast by ID. Parameters ---------- id : str ID of the broadcast you want to fetch. Returns ------- Broadcast \"\"\" data = await self . fetch ( method = \"GET\" , route = f \"/broadcasts/ { id } \" ) if data [ \"status\" ] == \"success\" : payload = data [ \"data\" ] payload [ \"source\" ] = \"strapi\" return Broadcast ( payload = payload ) else : return None async def get_broadcasts ( self ) -> Optional [ Broadcasts ]: \"\"\" Fetches all the currently active broadcasts. Returns ------- Broadcasts \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/broadcasts\" ) if data [ \"status\" ] == \"success\" : broadcasts = [] if len ( data [ \"data\" ]): for broadcast in data [ \"data\" ]: payload = broadcast payload [ \"source\" ] = \"strapi\" broadcasts . append ( Broadcast ( payload = payload )) return Broadcasts ( contents = broadcasts ) else : return None async def get_last_broadcast ( self , username : str ) -> Optional [ Broadcast ]: \"\"\" Gets the last broadcast of a user. Parameters ---------- username : str The username of the user you want to get the last broadcast for. Returns ------- Broadcast \"\"\" user = await self . reddit . redditor ( username ) async for submission in user . submissions . new ( limit = 25 ): if self . is_rpan_broadcast ( submission . url ): return await self . submission_to_broadcast ( submission ) return None async def get_top_broadcasts ( self , time_period : str = None ) -> tuple : \"\"\" Gets the top broadcast on each subreddit (from within a specific time period). Parameters ---------- time_period : str The time period from which you would like to get the top broadcasts for. Returns ------- tuple \"\"\" allowed_time_periods = [ \"hour\" , \"day\" , \"week\" , \"month\" , \"year\" , \"all\" , ] if time_period : time_period = time_period . lower () if time_period not in allowed_time_periods : time_period = \"week\" if time_period in self . top_broadcasts_cache : return self . top_broadcasts_cache [ time_period ], time_period else : top_broadcasts = {} for subreddit in constants . RPAN_SUBREDDITS : subreddit = await self . reddit . subreddit ( subreddit ) async for submission in subreddit . search ( 'flair_name:\"Broadcast\"' , sort = \"top\" , time_filter = time_period , limit = 1 , ): top_broadcasts [ subreddit ] = submission self . top_broadcasts_cache [ time_period ] = top_broadcasts return top_broadcasts , time_period async def submission_to_broadcast ( self , submission : Submission ) -> Optional [ Broadcast ]: \"\"\" Turns a PRAW submission into a broadcast class. Parameters ---------- submission : str The submission to turn into a broadcast class. Returns ------- Broadcast \"\"\" return Broadcast ( payload = { \"post\" : { \"id\" : submission . fullname , \"title\" : submission . title , \"url\" : submission . url , \"authorInfo\" : { \"name\" : submission . author . name }, \"subreddit\" : { \"name\" : submission . subreddit . display_name }, }, \"stream\" : { \"state\" : \"IS_LIVE\" , # TODO: Switch stream state \"publish_at\" : submission . created_utc , }, } ) def format_broadcast_timestamp ( self , timestamp : int ) -> str : \"\"\" Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters ---------- timestamp : int The timestamp to format. Returns ------- str \"\"\" return datetime . fromtimestamp ( int ( timestamp ), tz = timezone . utc ) def is_rpan_broadcast ( self , link : str ) -> bool : \"\"\" Checks if a link is a valid RPAN broadcast. Parameters ---------- link : str The link to check. Returns ------- bool \"\"\" if \"reddit.com/rpan/\" in link : return True else : return False __init__ ( self , client_id , client_secret ) special Construct the PyRPAN wrapper. Parameters: Name Type Description Default client_id str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. required client_secret str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. required Source code in pyrpan\\client.py def __init__ ( self , client_id : str , client_secret : str ) -> None : \"\"\" Construct the PyRPAN wrapper. Parameters ---------- client_id : str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. client_secret : str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. \"\"\" self . api_url = \"https://strapi.reddit.com\" self . top_broadcasts_cache = ExpiringDict ( max_len = 3 , max_age_seconds = 300 ) self . reddit = Reddit ( client_id = client_id , client_secret = client_secret , user_agent = \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , ) self . _session = None self . _lock = asyncio . Lock () close ( self ) async Close the client session. Source code in pyrpan\\client.py async def close ( self ) -> None : \"\"\"Close the client session.\"\"\" if self . _session is not None : await self . _session . close () fetch ( self , method , route , * , headers = None , data = None ) async Fetching a response from the API Parameters: Name Type Description Default route str The API route you want to make a call to required headers Optional[dict] Headers for the API call, Defaults to None None data Optional[dict] Data for the API call, Defaults to None None Returns: Type Description Optional[dict] Source code in pyrpan\\client.py async def fetch ( self , method : str , route : str , * , headers : Optional [ dict ] = None , data : Optional [ dict ] = None ) -> Optional [ dict ]: \"\"\" Fetching a response from the API Parameters ---------- route : str The API route you want to make a call to headers : dict Headers for the API call, Defaults to None data : dict Data for the API call, Defaults to None Returns ------- Optional[dict] \"\"\" if headers is None : headers = {} headers = { \"User-Agent\" : \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , \"Cache-Control\" : \"no-cache\" , ** headers , } if not self . _session : self . _session = aiohttp . ClientSession () async with self . _lock : async with self . _session . request ( method = method , url = self . api_url + route , headers = headers , data = data ) as res : # Handle status codes if res . status in [ 200 , 201 , 204 ]: data = await res . json () if res . status == 400 : raise InvalidRequest ( \"Bad request - Request performed was invalid.\" ) if res . status == 429 : raise InvalidRequest ( \"Too many requests - Slow down your requests.\" ) if res . status == 500 : raise InvalidRequest ( \"Internal Server Error - Something went wrong.\" ) return data format_broadcast_timestamp ( self , timestamp ) Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters: Name Type Description Default timestamp int The timestamp to format. required Returns: Type Description str Source code in pyrpan\\client.py def format_broadcast_timestamp ( self , timestamp : int ) -> str : \"\"\" Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters ---------- timestamp : int The timestamp to format. Returns ------- str \"\"\" return datetime . fromtimestamp ( int ( timestamp ), tz = timezone . utc ) get_broadcast ( self , id ) async Gets a broadcast by ID. Parameters: Name Type Description Default id str ID of the broadcast you want to fetch. required Returns: Type Description Optional[pyrpan.models.Broadcast] Source code in pyrpan\\client.py async def get_broadcast ( self , id : str ) -> Optional [ Broadcast ]: \"\"\" Gets a broadcast by ID. Parameters ---------- id : str ID of the broadcast you want to fetch. Returns ------- Broadcast \"\"\" data = await self . fetch ( method = \"GET\" , route = f \"/broadcasts/ { id } \" ) if data [ \"status\" ] == \"success\" : payload = data [ \"data\" ] payload [ \"source\" ] = \"strapi\" return Broadcast ( payload = payload ) else : return None get_broadcasts ( self ) async Fetches all the currently active broadcasts. Returns: Type Description Optional[pyrpan.models.Broadcasts] Source code in pyrpan\\client.py async def get_broadcasts ( self ) -> Optional [ Broadcasts ]: \"\"\" Fetches all the currently active broadcasts. Returns ------- Broadcasts \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/broadcasts\" ) if data [ \"status\" ] == \"success\" : broadcasts = [] if len ( data [ \"data\" ]): for broadcast in data [ \"data\" ]: payload = broadcast payload [ \"source\" ] = \"strapi\" broadcasts . append ( Broadcast ( payload = payload )) return Broadcasts ( contents = broadcasts ) else : return None get_last_broadcast ( self , username ) async Gets the last broadcast of a user. Parameters: Name Type Description Default username str The username of the user you want to get the last broadcast for. required Returns: Type Description Optional[pyrpan.models.Broadcast] Source code in pyrpan\\client.py async def get_last_broadcast ( self , username : str ) -> Optional [ Broadcast ]: \"\"\" Gets the last broadcast of a user. Parameters ---------- username : str The username of the user you want to get the last broadcast for. Returns ------- Broadcast \"\"\" user = await self . reddit . redditor ( username ) async for submission in user . submissions . new ( limit = 25 ): if self . is_rpan_broadcast ( submission . url ): return await self . submission_to_broadcast ( submission ) return None get_top_broadcasts ( self , time_period = None ) async Gets the top broadcast on each subreddit (from within a specific time period). Parameters: Name Type Description Default time_period str The time period from which you would like to get the top broadcasts for. None Returns: Type Description tuple Source code in pyrpan\\client.py async def get_top_broadcasts ( self , time_period : str = None ) -> tuple : \"\"\" Gets the top broadcast on each subreddit (from within a specific time period). Parameters ---------- time_period : str The time period from which you would like to get the top broadcasts for. Returns ------- tuple \"\"\" allowed_time_periods = [ \"hour\" , \"day\" , \"week\" , \"month\" , \"year\" , \"all\" , ] if time_period : time_period = time_period . lower () if time_period not in allowed_time_periods : time_period = \"week\" if time_period in self . top_broadcasts_cache : return self . top_broadcasts_cache [ time_period ], time_period else : top_broadcasts = {} for subreddit in constants . RPAN_SUBREDDITS : subreddit = await self . reddit . subreddit ( subreddit ) async for submission in subreddit . search ( 'flair_name:\"Broadcast\"' , sort = \"top\" , time_filter = time_period , limit = 1 , ): top_broadcasts [ subreddit ] = submission self . top_broadcasts_cache [ time_period ] = top_broadcasts return top_broadcasts , time_period get_viewer_subreddits ( self ) async Gets a list of the recommended viewer RPAN subreddits. Returns: Type Description list Source code in pyrpan\\client.py async def get_viewer_subreddits ( self ) -> list : \"\"\" Gets a list of the recommended viewer RPAN subreddits. Returns ------- list \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/recommended_viewer_subreddits\" ) return data [ \"data\" ] is_rpan_broadcast ( self , link ) Checks if a link is a valid RPAN broadcast. Parameters: Name Type Description Default link str The link to check. required Returns: Type Description bool Source code in pyrpan\\client.py def is_rpan_broadcast ( self , link : str ) -> bool : \"\"\" Checks if a link is a valid RPAN broadcast. Parameters ---------- link : str The link to check. Returns ------- bool \"\"\" if \"reddit.com/rpan/\" in link : return True else : return False submission_to_broadcast ( self , submission ) async Turns a PRAW submission into a broadcast class. Parameters: Name Type Description Default submission Submission The submission to turn into a broadcast class. required Returns: Type Description Optional[pyrpan.models.Broadcast] Source code in pyrpan\\client.py async def submission_to_broadcast ( self , submission : Submission ) -> Optional [ Broadcast ]: \"\"\" Turns a PRAW submission into a broadcast class. Parameters ---------- submission : str The submission to turn into a broadcast class. Returns ------- Broadcast \"\"\" return Broadcast ( payload = { \"post\" : { \"id\" : submission . fullname , \"title\" : submission . title , \"url\" : submission . url , \"authorInfo\" : { \"name\" : submission . author . name }, \"subreddit\" : { \"name\" : submission . subreddit . display_name }, }, \"stream\" : { \"state\" : \"IS_LIVE\" , # TODO: Switch stream state \"publish_at\" : submission . created_utc , }, } ) models Broadcasts Source code in pyrpan\\models.py class Broadcasts : def __init__ ( self , contents : list = None ) -> None : self . broadcasts = [] if contents : self . broadcasts = contents def top_broadcast ( self , subreddit : str = None ) -> Union [ Broadcast , None ]: \"\"\" Gets the top broadcast. Parameters ---------- subreddit : str Optional paramater to find the top broadcast on a specific subreddit. Returns ------- Broadcast \"\"\" if not len ( self . broadcasts ): return None if subreddit is None : return self . broadcasts [ 0 ] else : subreddit = subreddit . lower () for broadcast in self . broadcasts : if broadcast . subreddit_name . lower () == subreddit : return broadcast return None def has_broadcast ( self , id : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast with a specified id. Parameters ---------- id : str The ID of the broadcast. Returns ------- Broadcast \"\"\" for broadcast in self . broadcasts : if broadcast . id == id : return broadcast return False def has_streamer ( self , name : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast from a specified user. Parameters ---------- name : str The streamer to search for. Returns ------- Broadcast \"\"\" name = name . lower () for broadcast in self . broadcasts : if broadcast . author_name . lower () == name : return broadcast return False def __repr__ ( self ) -> str : return f \"Broadcasts( { ', ' . join ( repr ( broadcast ) for broadcast in self . broadcasts ) } )\" has_broadcast ( self , id ) Checks if the broadcast list contains a broadcast with a specified id. Parameters: Name Type Description Default id str The ID of the broadcast. required Returns: Type Description Union[pyrpan.models.Broadcast, bool] Source code in pyrpan\\models.py def has_broadcast ( self , id : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast with a specified id. Parameters ---------- id : str The ID of the broadcast. Returns ------- Broadcast \"\"\" for broadcast in self . broadcasts : if broadcast . id == id : return broadcast return False has_streamer ( self , name ) Checks if the broadcast list contains a broadcast from a specified user. Parameters: Name Type Description Default name str The streamer to search for. required Returns: Type Description Union[pyrpan.models.Broadcast, bool] Source code in pyrpan\\models.py def has_streamer ( self , name : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast from a specified user. Parameters ---------- name : str The streamer to search for. Returns ------- Broadcast \"\"\" name = name . lower () for broadcast in self . broadcasts : if broadcast . author_name . lower () == name : return broadcast return False top_broadcast ( self , subreddit = None ) Gets the top broadcast. Parameters: Name Type Description Default subreddit str Optional paramater to find the top broadcast on a specific subreddit. None Returns: Type Description Optional[pyrpan.models.Broadcast] Source code in pyrpan\\models.py def top_broadcast ( self , subreddit : str = None ) -> Union [ Broadcast , None ]: \"\"\" Gets the top broadcast. Parameters ---------- subreddit : str Optional paramater to find the top broadcast on a specific subreddit. Returns ------- Broadcast \"\"\" if not len ( self . broadcasts ): return None if subreddit is None : return self . broadcasts [ 0 ] else : subreddit = subreddit . lower () for broadcast in self . broadcasts : if broadcast . subreddit_name . lower () == subreddit : return broadcast return None","title":"Code Reference"},{"location":"code-reference/#code-reference","text":"","title":"Code Reference"},{"location":"code-reference/#pyrpan.client","text":"","title":"client"},{"location":"code-reference/#pyrpan.client.PyRPAN","text":"Client class for the PyRPAN API Wrapper. Attributes: Name Type Description reddit str The Reddit instance to use to access the Reddit API. top_broadcasts_cache ExpiringDict A cache of the top broadcasts. api_url str URL to access the RPAN API. session aiohttp.ClientSession For creating client session and to make requests. Source code in pyrpan\\client.py class PyRPAN : \"\"\" Client class for the PyRPAN API Wrapper. Attributes ---------- reddit : str The Reddit instance to use to access the Reddit API. top_broadcasts_cache : ExpiringDict A cache of the top broadcasts. api_url : str URL to access the RPAN API. session : aiohttp.ClientSession For creating client session and to make requests. \"\"\" def __init__ ( self , client_id : str , client_secret : str ) -> None : \"\"\" Construct the PyRPAN wrapper. Parameters ---------- client_id : str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. client_secret : str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. \"\"\" self . api_url = \"https://strapi.reddit.com\" self . top_broadcasts_cache = ExpiringDict ( max_len = 3 , max_age_seconds = 300 ) self . reddit = Reddit ( client_id = client_id , client_secret = client_secret , user_agent = \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , ) self . _session = None self . _lock = asyncio . Lock () async def close ( self ) -> None : \"\"\"Close the client session.\"\"\" if self . _session is not None : await self . _session . close () async def fetch ( self , method : str , route : str , * , headers : Optional [ dict ] = None , data : Optional [ dict ] = None ) -> Optional [ dict ]: \"\"\" Fetching a response from the API Parameters ---------- route : str The API route you want to make a call to headers : dict Headers for the API call, Defaults to None data : dict Data for the API call, Defaults to None Returns ------- Optional[dict] \"\"\" if headers is None : headers = {} headers = { \"User-Agent\" : \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , \"Cache-Control\" : \"no-cache\" , ** headers , } if not self . _session : self . _session = aiohttp . ClientSession () async with self . _lock : async with self . _session . request ( method = method , url = self . api_url + route , headers = headers , data = data ) as res : # Handle status codes if res . status in [ 200 , 201 , 204 ]: data = await res . json () if res . status == 400 : raise InvalidRequest ( \"Bad request - Request performed was invalid.\" ) if res . status == 429 : raise InvalidRequest ( \"Too many requests - Slow down your requests.\" ) if res . status == 500 : raise InvalidRequest ( \"Internal Server Error - Something went wrong.\" ) return data async def get_viewer_subreddits ( self ) -> list : \"\"\" Gets a list of the recommended viewer RPAN subreddits. Returns ------- list \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/recommended_viewer_subreddits\" ) return data [ \"data\" ] async def get_broadcast ( self , id : str ) -> Optional [ Broadcast ]: \"\"\" Gets a broadcast by ID. Parameters ---------- id : str ID of the broadcast you want to fetch. Returns ------- Broadcast \"\"\" data = await self . fetch ( method = \"GET\" , route = f \"/broadcasts/ { id } \" ) if data [ \"status\" ] == \"success\" : payload = data [ \"data\" ] payload [ \"source\" ] = \"strapi\" return Broadcast ( payload = payload ) else : return None async def get_broadcasts ( self ) -> Optional [ Broadcasts ]: \"\"\" Fetches all the currently active broadcasts. Returns ------- Broadcasts \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/broadcasts\" ) if data [ \"status\" ] == \"success\" : broadcasts = [] if len ( data [ \"data\" ]): for broadcast in data [ \"data\" ]: payload = broadcast payload [ \"source\" ] = \"strapi\" broadcasts . append ( Broadcast ( payload = payload )) return Broadcasts ( contents = broadcasts ) else : return None async def get_last_broadcast ( self , username : str ) -> Optional [ Broadcast ]: \"\"\" Gets the last broadcast of a user. Parameters ---------- username : str The username of the user you want to get the last broadcast for. Returns ------- Broadcast \"\"\" user = await self . reddit . redditor ( username ) async for submission in user . submissions . new ( limit = 25 ): if self . is_rpan_broadcast ( submission . url ): return await self . submission_to_broadcast ( submission ) return None async def get_top_broadcasts ( self , time_period : str = None ) -> tuple : \"\"\" Gets the top broadcast on each subreddit (from within a specific time period). Parameters ---------- time_period : str The time period from which you would like to get the top broadcasts for. Returns ------- tuple \"\"\" allowed_time_periods = [ \"hour\" , \"day\" , \"week\" , \"month\" , \"year\" , \"all\" , ] if time_period : time_period = time_period . lower () if time_period not in allowed_time_periods : time_period = \"week\" if time_period in self . top_broadcasts_cache : return self . top_broadcasts_cache [ time_period ], time_period else : top_broadcasts = {} for subreddit in constants . RPAN_SUBREDDITS : subreddit = await self . reddit . subreddit ( subreddit ) async for submission in subreddit . search ( 'flair_name:\"Broadcast\"' , sort = \"top\" , time_filter = time_period , limit = 1 , ): top_broadcasts [ subreddit ] = submission self . top_broadcasts_cache [ time_period ] = top_broadcasts return top_broadcasts , time_period async def submission_to_broadcast ( self , submission : Submission ) -> Optional [ Broadcast ]: \"\"\" Turns a PRAW submission into a broadcast class. Parameters ---------- submission : str The submission to turn into a broadcast class. Returns ------- Broadcast \"\"\" return Broadcast ( payload = { \"post\" : { \"id\" : submission . fullname , \"title\" : submission . title , \"url\" : submission . url , \"authorInfo\" : { \"name\" : submission . author . name }, \"subreddit\" : { \"name\" : submission . subreddit . display_name }, }, \"stream\" : { \"state\" : \"IS_LIVE\" , # TODO: Switch stream state \"publish_at\" : submission . created_utc , }, } ) def format_broadcast_timestamp ( self , timestamp : int ) -> str : \"\"\" Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters ---------- timestamp : int The timestamp to format. Returns ------- str \"\"\" return datetime . fromtimestamp ( int ( timestamp ), tz = timezone . utc ) def is_rpan_broadcast ( self , link : str ) -> bool : \"\"\" Checks if a link is a valid RPAN broadcast. Parameters ---------- link : str The link to check. Returns ------- bool \"\"\" if \"reddit.com/rpan/\" in link : return True else : return False","title":"PyRPAN"},{"location":"code-reference/#pyrpan.client.PyRPAN.__init__","text":"Construct the PyRPAN wrapper. Parameters: Name Type Description Default client_id str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. required client_secret str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. required Source code in pyrpan\\client.py def __init__ ( self , client_id : str , client_secret : str ) -> None : \"\"\" Construct the PyRPAN wrapper. Parameters ---------- client_id : str Client ID generated from creating an app at https://old.reddit.com/prefs/apps/. client_secret : str Client Secrt generated from creating an app at https://old.reddit.com/prefs/apps/. \"\"\" self . api_url = \"https://strapi.reddit.com\" self . top_broadcasts_cache = ExpiringDict ( max_len = 3 , max_age_seconds = 300 ) self . reddit = Reddit ( client_id = client_id , client_secret = client_secret , user_agent = \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , ) self . _session = None self . _lock = asyncio . Lock ()","title":"__init__()"},{"location":"code-reference/#pyrpan.client.PyRPAN.close","text":"Close the client session. Source code in pyrpan\\client.py async def close ( self ) -> None : \"\"\"Close the client session.\"\"\" if self . _session is not None : await self . _session . close ()","title":"close()"},{"location":"code-reference/#pyrpan.client.PyRPAN.fetch","text":"Fetching a response from the API Parameters: Name Type Description Default route str The API route you want to make a call to required headers Optional[dict] Headers for the API call, Defaults to None None data Optional[dict] Data for the API call, Defaults to None None Returns: Type Description Optional[dict] Source code in pyrpan\\client.py async def fetch ( self , method : str , route : str , * , headers : Optional [ dict ] = None , data : Optional [ dict ] = None ) -> Optional [ dict ]: \"\"\" Fetching a response from the API Parameters ---------- route : str The API route you want to make a call to headers : dict Headers for the API call, Defaults to None data : dict Data for the API call, Defaults to None Returns ------- Optional[dict] \"\"\" if headers is None : headers = {} headers = { \"User-Agent\" : \"Reddit Public Access Network (RPAN) API Wrapper by b1uejay27.\" , \"Cache-Control\" : \"no-cache\" , ** headers , } if not self . _session : self . _session = aiohttp . ClientSession () async with self . _lock : async with self . _session . request ( method = method , url = self . api_url + route , headers = headers , data = data ) as res : # Handle status codes if res . status in [ 200 , 201 , 204 ]: data = await res . json () if res . status == 400 : raise InvalidRequest ( \"Bad request - Request performed was invalid.\" ) if res . status == 429 : raise InvalidRequest ( \"Too many requests - Slow down your requests.\" ) if res . status == 500 : raise InvalidRequest ( \"Internal Server Error - Something went wrong.\" ) return data","title":"fetch()"},{"location":"code-reference/#pyrpan.client.PyRPAN.format_broadcast_timestamp","text":"Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters: Name Type Description Default timestamp int The timestamp to format. required Returns: Type Description str Source code in pyrpan\\client.py def format_broadcast_timestamp ( self , timestamp : int ) -> str : \"\"\" Formats a timestamp of a broadcast. This is used by the broadcast notifications. Parameters ---------- timestamp : int The timestamp to format. Returns ------- str \"\"\" return datetime . fromtimestamp ( int ( timestamp ), tz = timezone . utc )","title":"format_broadcast_timestamp()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_broadcast","text":"Gets a broadcast by ID. Parameters: Name Type Description Default id str ID of the broadcast you want to fetch. required Returns: Type Description Optional[pyrpan.models.Broadcast] Source code in pyrpan\\client.py async def get_broadcast ( self , id : str ) -> Optional [ Broadcast ]: \"\"\" Gets a broadcast by ID. Parameters ---------- id : str ID of the broadcast you want to fetch. Returns ------- Broadcast \"\"\" data = await self . fetch ( method = \"GET\" , route = f \"/broadcasts/ { id } \" ) if data [ \"status\" ] == \"success\" : payload = data [ \"data\" ] payload [ \"source\" ] = \"strapi\" return Broadcast ( payload = payload ) else : return None","title":"get_broadcast()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_broadcasts","text":"Fetches all the currently active broadcasts. Returns: Type Description Optional[pyrpan.models.Broadcasts] Source code in pyrpan\\client.py async def get_broadcasts ( self ) -> Optional [ Broadcasts ]: \"\"\" Fetches all the currently active broadcasts. Returns ------- Broadcasts \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/broadcasts\" ) if data [ \"status\" ] == \"success\" : broadcasts = [] if len ( data [ \"data\" ]): for broadcast in data [ \"data\" ]: payload = broadcast payload [ \"source\" ] = \"strapi\" broadcasts . append ( Broadcast ( payload = payload )) return Broadcasts ( contents = broadcasts ) else : return None","title":"get_broadcasts()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_last_broadcast","text":"Gets the last broadcast of a user. Parameters: Name Type Description Default username str The username of the user you want to get the last broadcast for. required Returns: Type Description Optional[pyrpan.models.Broadcast] Source code in pyrpan\\client.py async def get_last_broadcast ( self , username : str ) -> Optional [ Broadcast ]: \"\"\" Gets the last broadcast of a user. Parameters ---------- username : str The username of the user you want to get the last broadcast for. Returns ------- Broadcast \"\"\" user = await self . reddit . redditor ( username ) async for submission in user . submissions . new ( limit = 25 ): if self . is_rpan_broadcast ( submission . url ): return await self . submission_to_broadcast ( submission ) return None","title":"get_last_broadcast()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_top_broadcasts","text":"Gets the top broadcast on each subreddit (from within a specific time period). Parameters: Name Type Description Default time_period str The time period from which you would like to get the top broadcasts for. None Returns: Type Description tuple Source code in pyrpan\\client.py async def get_top_broadcasts ( self , time_period : str = None ) -> tuple : \"\"\" Gets the top broadcast on each subreddit (from within a specific time period). Parameters ---------- time_period : str The time period from which you would like to get the top broadcasts for. Returns ------- tuple \"\"\" allowed_time_periods = [ \"hour\" , \"day\" , \"week\" , \"month\" , \"year\" , \"all\" , ] if time_period : time_period = time_period . lower () if time_period not in allowed_time_periods : time_period = \"week\" if time_period in self . top_broadcasts_cache : return self . top_broadcasts_cache [ time_period ], time_period else : top_broadcasts = {} for subreddit in constants . RPAN_SUBREDDITS : subreddit = await self . reddit . subreddit ( subreddit ) async for submission in subreddit . search ( 'flair_name:\"Broadcast\"' , sort = \"top\" , time_filter = time_period , limit = 1 , ): top_broadcasts [ subreddit ] = submission self . top_broadcasts_cache [ time_period ] = top_broadcasts return top_broadcasts , time_period","title":"get_top_broadcasts()"},{"location":"code-reference/#pyrpan.client.PyRPAN.get_viewer_subreddits","text":"Gets a list of the recommended viewer RPAN subreddits. Returns: Type Description list Source code in pyrpan\\client.py async def get_viewer_subreddits ( self ) -> list : \"\"\" Gets a list of the recommended viewer RPAN subreddits. Returns ------- list \"\"\" data = await self . fetch ( method = \"GET\" , route = \"/recommended_viewer_subreddits\" ) return data [ \"data\" ]","title":"get_viewer_subreddits()"},{"location":"code-reference/#pyrpan.client.PyRPAN.is_rpan_broadcast","text":"Checks if a link is a valid RPAN broadcast. Parameters: Name Type Description Default link str The link to check. required Returns: Type Description bool Source code in pyrpan\\client.py def is_rpan_broadcast ( self , link : str ) -> bool : \"\"\" Checks if a link is a valid RPAN broadcast. Parameters ---------- link : str The link to check. Returns ------- bool \"\"\" if \"reddit.com/rpan/\" in link : return True else : return False","title":"is_rpan_broadcast()"},{"location":"code-reference/#pyrpan.client.PyRPAN.submission_to_broadcast","text":"Turns a PRAW submission into a broadcast class. Parameters: Name Type Description Default submission Submission The submission to turn into a broadcast class. required Returns: Type Description Optional[pyrpan.models.Broadcast] Source code in pyrpan\\client.py async def submission_to_broadcast ( self , submission : Submission ) -> Optional [ Broadcast ]: \"\"\" Turns a PRAW submission into a broadcast class. Parameters ---------- submission : str The submission to turn into a broadcast class. Returns ------- Broadcast \"\"\" return Broadcast ( payload = { \"post\" : { \"id\" : submission . fullname , \"title\" : submission . title , \"url\" : submission . url , \"authorInfo\" : { \"name\" : submission . author . name }, \"subreddit\" : { \"name\" : submission . subreddit . display_name }, }, \"stream\" : { \"state\" : \"IS_LIVE\" , # TODO: Switch stream state \"publish_at\" : submission . created_utc , }, } )","title":"submission_to_broadcast()"},{"location":"code-reference/#pyrpan.models","text":"","title":"models"},{"location":"code-reference/#pyrpan.models.Broadcasts","text":"Source code in pyrpan\\models.py class Broadcasts : def __init__ ( self , contents : list = None ) -> None : self . broadcasts = [] if contents : self . broadcasts = contents def top_broadcast ( self , subreddit : str = None ) -> Union [ Broadcast , None ]: \"\"\" Gets the top broadcast. Parameters ---------- subreddit : str Optional paramater to find the top broadcast on a specific subreddit. Returns ------- Broadcast \"\"\" if not len ( self . broadcasts ): return None if subreddit is None : return self . broadcasts [ 0 ] else : subreddit = subreddit . lower () for broadcast in self . broadcasts : if broadcast . subreddit_name . lower () == subreddit : return broadcast return None def has_broadcast ( self , id : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast with a specified id. Parameters ---------- id : str The ID of the broadcast. Returns ------- Broadcast \"\"\" for broadcast in self . broadcasts : if broadcast . id == id : return broadcast return False def has_streamer ( self , name : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast from a specified user. Parameters ---------- name : str The streamer to search for. Returns ------- Broadcast \"\"\" name = name . lower () for broadcast in self . broadcasts : if broadcast . author_name . lower () == name : return broadcast return False def __repr__ ( self ) -> str : return f \"Broadcasts( { ', ' . join ( repr ( broadcast ) for broadcast in self . broadcasts ) } )\"","title":"Broadcasts"},{"location":"code-reference/#pyrpan.models.Broadcasts.has_broadcast","text":"Checks if the broadcast list contains a broadcast with a specified id. Parameters: Name Type Description Default id str The ID of the broadcast. required Returns: Type Description Union[pyrpan.models.Broadcast, bool] Source code in pyrpan\\models.py def has_broadcast ( self , id : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast with a specified id. Parameters ---------- id : str The ID of the broadcast. Returns ------- Broadcast \"\"\" for broadcast in self . broadcasts : if broadcast . id == id : return broadcast return False","title":"has_broadcast()"},{"location":"code-reference/#pyrpan.models.Broadcasts.has_streamer","text":"Checks if the broadcast list contains a broadcast from a specified user. Parameters: Name Type Description Default name str The streamer to search for. required Returns: Type Description Union[pyrpan.models.Broadcast, bool] Source code in pyrpan\\models.py def has_streamer ( self , name : str ) -> Union [ Broadcast , bool ]: \"\"\" Checks if the broadcast list contains a broadcast from a specified user. Parameters ---------- name : str The streamer to search for. Returns ------- Broadcast \"\"\" name = name . lower () for broadcast in self . broadcasts : if broadcast . author_name . lower () == name : return broadcast return False","title":"has_streamer()"},{"location":"code-reference/#pyrpan.models.Broadcasts.top_broadcast","text":"Gets the top broadcast. Parameters: Name Type Description Default subreddit str Optional paramater to find the top broadcast on a specific subreddit. None Returns: Type Description Optional[pyrpan.models.Broadcast] Source code in pyrpan\\models.py def top_broadcast ( self , subreddit : str = None ) -> Union [ Broadcast , None ]: \"\"\" Gets the top broadcast. Parameters ---------- subreddit : str Optional paramater to find the top broadcast on a specific subreddit. Returns ------- Broadcast \"\"\" if not len ( self . broadcasts ): return None if subreddit is None : return self . broadcasts [ 0 ] else : subreddit = subreddit . lower () for broadcast in self . broadcasts : if broadcast . subreddit_name . lower () == subreddit : return broadcast return None","title":"top_broadcast()"},{"location":"installation/","text":"Installation To install PyRPAN, run the following command from the command line: pip install pyrpan To install the development version of PyRPAN, run the following command from the command line: pip install git+https://github.com/b1uejay27/PyRPAN.git","title":"Installation"},{"location":"installation/#installation","text":"To install PyRPAN, run the following command from the command line: pip install pyrpan To install the development version of PyRPAN, run the following command from the command line: pip install git+https://github.com/b1uejay27/PyRPAN.git","title":"Installation"}]}